package frc.robot;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.HashMap;

import edu.wpi.first.wpilibj.vision.VisionPipeline;

import org.opencv.core.*;
import org.opencv.core.Core.*;
import org.opencv.features2d.FeatureDetector;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.*;
import org.opencv.objdetect.*;

/**
* GRIPVisionProcessor class.
*
* <p>An OpenCV pipeline generated by GRIP.
*
* @author GRIP
*/
@SuppressWarnings({"unused", "deprecation"})
public class GRIPVisionProcessor implements VisionPipeline {

	//Outputs
	private Mat resizeImageOutput = new Mat();
	private Mat rgbThresholdOutput = new Mat();
	private Point newPointOutput = new Point();
	private Mat cvErodeOutput = new Mat();
	private Mat mask0Output = new Mat();
	private Mat thresholdMovingOutput = new Mat();
	private Mat cvBitwiseNotOutput = new Mat();
	private Mat mask1Output = new Mat();
	private MatOfKeyPoint findBlobsOutput = new MatOfKeyPoint();


	//Moving Thresholds
    private Mat lastImage0 = new Mat();
	static {
		System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
	}

	/**
	 * This is the primary method that runs the entire pipeline and updates the outputs.
	 */
	@Override	public void process(Mat source0) {
		// Step Resize_Image0:
		Mat resizeImageInput = source0;
		double resizeImageWidth = 640.0;
		double resizeImageHeight = 480.0;
		int resizeImageInterpolation = Imgproc.INTER_CUBIC;
		resizeImage(resizeImageInput, resizeImageWidth, resizeImageHeight, resizeImageInterpolation, resizeImageOutput);

		// Step RGB_Threshold0:
		Mat rgbThresholdInput = resizeImageOutput;
		double[] rgbThresholdRed = {55.22598870056497, 146.4239155676266};
		double[] rgbThresholdGreen = {86.44067796610167, 255.0};
		double[] rgbThresholdBlue = {129.66101694915253, 255.0};
		rgbThreshold(rgbThresholdInput, rgbThresholdRed, rgbThresholdGreen, rgbThresholdBlue, rgbThresholdOutput);

		// Step New_Point0:
		double newPointX = 0.5;
		double newPointY = 0.5;
		newPoint(newPointX, newPointY, newPointOutput);

		// Step CV_erode0:
		Mat cvErodeSrc = rgbThresholdOutput;
		Mat cvErodeKernel = new Mat();
		Point cvErodeAnchor = newPointOutput;
		double cvErodeIterations = 0.0;
		int cvErodeBordertype = Core.BORDER_CONSTANT;
		Scalar cvErodeBordervalue = new Scalar(-1);
		cvErode(cvErodeSrc, cvErodeKernel, cvErodeAnchor, cvErodeIterations, cvErodeBordertype, cvErodeBordervalue, cvErodeOutput);

		// Step Mask0:
		Mat mask0Input = resizeImageOutput;
		Mat mask0Mask = cvErodeOutput;
		mask(mask0Input, mask0Mask, mask0Output);

		// Step Threshold_Moving0:
		Mat thresholdMovingImage = mask0Output;
		thresholdMoving(thresholdMovingImage, this.lastImage0, thresholdMovingOutput);

		// Step CV_bitwise_not0:
		Mat cvBitwiseNotSrc1 = thresholdMovingOutput;
		cvBitwiseNot(cvBitwiseNotSrc1, cvBitwiseNotOutput);

		// Step Mask1:
		Mat mask1Input = mask0Output;
		Mat mask1Mask = cvBitwiseNotOutput;
		mask(mask1Input, mask1Mask, mask1Output);

		// Step Find_Blobs0:
		Mat findBlobsInput = mask1Output;
		double findBlobsMinArea = 40.0;
		double[] findBlobsCircularity = {0.0, 1.0};
		boolean findBlobsDarkBlobs = true;
		findBlobs(findBlobsInput, findBlobsMinArea, findBlobsCircularity, findBlobsDarkBlobs, findBlobsOutput);

	}

	/**
	 * This method is a generated getter for the output of a Resize_Image.
	 * @return Mat output from Resize_Image.
	 */
	public Mat resizeImageOutput() {
		return resizeImageOutput;
	}

	/**
	 * This method is a generated getter for the output of a RGB_Threshold.
	 * @return Mat output from RGB_Threshold.
	 */
	public Mat rgbThresholdOutput() {
		return rgbThresholdOutput;
	}

	/**
	 * This method is a generated getter for the output of a New_Point.
	 * @return Point output from New_Point.
	 */
	public Point newPointOutput() {
		return newPointOutput;
	}

	/**
	 * This method is a generated getter for the output of a CV_erode.
	 * @return Mat output from CV_erode.
	 */
	public Mat cvErodeOutput() {
		return cvErodeOutput;
	}

	/**
	 * This method is a generated getter for the output of a Mask.
	 * @return Mat output from Mask.
	 */
	public Mat mask0Output() {
		return mask0Output;
	}

	/**
	 * This method is a generated getter for the output of a Threshold_Moving.
	 * @return Mat output from Threshold_Moving.
	 */
	public Mat thresholdMovingOutput() {
		return thresholdMovingOutput;
	}

	/**
	 * This method is a generated getter for the output of a CV_bitwise_not.
	 * @return Mat output from CV_bitwise_not.
	 */
	public Mat cvBitwiseNotOutput() {
		return cvBitwiseNotOutput;
	}

	/**
	 * This method is a generated getter for the output of a Mask.
	 * @return Mat output from Mask.
	 */
	public Mat mask1Output() {
		return mask1Output;
	}

	/**
	 * This method is a generated getter for the output of a Find_Blobs.
	 * @return MatOfKeyPoint output from Find_Blobs.
	 */
	public MatOfKeyPoint findBlobsOutput() {
		return findBlobsOutput;
	}


	/**
	 * Scales and image to an exact size.
	 * @param input The image on which to perform the Resize.
	 * @param width The width of the output in pixels.
	 * @param height The height of the output in pixels.
	 * @param interpolation The type of interpolation.
	 * @param output The image in which to store the output.
	 */
	private void resizeImage(Mat input, double width, double height,
		int interpolation, Mat output) {
		Imgproc.resize(input, output, new Size(width, height), 0.0, 0.0, interpolation);
	}

	/**
	 * Segment an image based on color ranges.
	 * @param input The image on which to perform the RGB threshold.
	 * @param red The min and max red.
	 * @param green The min and max green.
	 * @param blue The min and max blue.
	 * @param output The image in which to store the output.
	 */
	private void rgbThreshold(Mat input, double[] red, double[] green, double[] blue,
		Mat out) {
		Imgproc.cvtColor(input, out, Imgproc.COLOR_BGR2RGB);
		Core.inRange(out, new Scalar(red[0], green[0], blue[0]),
			new Scalar(red[1], green[1], blue[1]), out);
	}

	/**
	 * Fills a point with given x and y values.
	 * @param x the x value to put in the point
	 * @param y the y value to put in the point
	 * @param point the point to fill
	 */
	private void newPoint(double x, double y, Point point) {
		point.x = x;
		point.y = y;
	}

	/**
	 * Expands area of lower value in an image.
	 * @param src the Image to erode.
	 * @param kernel the kernel for erosion.
	 * @param anchor the center of the kernel.
	 * @param iterations the number of times to perform the erosion.
	 * @param borderType pixel extrapolation method.
	 * @param borderValue value to be used for a constant border.
	 * @param dst Output Image.
	 */
	private void cvErode(Mat src, Mat kernel, Point anchor, double iterations,
		int borderType, Scalar borderValue, Mat dst) {
		if (kernel == null) {
			kernel = new Mat();
		}
		if (anchor == null) {
			anchor = new Point(-1,-1);
		}
		if (borderValue == null) {
			borderValue = new Scalar(-1);
		}
		Imgproc.erode(src, dst, kernel, anchor, (int)iterations, borderType, borderValue);
	}

	/**
	 * Thresholds off parts of the image that have moved or changed between the previous and next image.
	 * @param input The image on which to perform the Threshold Moving.
	 * @param lastImage The mat where the previous image is stored.
	 * @param output The image in which to store the output.
	 */
	private void thresholdMoving(Mat input, Mat lastImage, Mat output) {
		Size lastSize = lastImage.size();
		Size inputSize = input.size();
		if (!lastImage.empty() && lastSize.height == inputSize.height && lastSize.width == inputSize.width) {
			Core.absdiff(input, lastImage, output);
		}
		input.copyTo(lastImage);
	}

	/**
	 * Computes the per element inverse of an image.
	 * @param src the image to invert.
	 * @param dst the inversion of the input image.
	 */
	private void cvBitwiseNot(Mat src, Mat dst) {
		Core.bitwise_not(src, dst);
	}

	/**
	 * Filter out an area of an image using a binary mask.
	 * @param input The image on which the mask filters.
	 * @param mask The binary image that is used to filter.
	 * @param output The image in which to store the output.
	 */
	private void mask(Mat input, Mat mask, Mat output) {
		mask.convertTo(mask, CvType.CV_8UC1);
		Core.bitwise_xor(output, output, output);
		input.copyTo(output, mask);
	}

	/**
	 * Detects groups of pixels in an image.
	 * @param input The image on which to perform the find blobs.
	 * @param minArea The minimum size of a blob that will be found
	 * @param circularity The minimum and maximum circularity of blobs that will be found
	 * @param darkBlobs The boolean that determines if light or dark blobs are found.
	 * @param blobList The output where the MatOfKeyPoint is stored.
	 */
	private void findBlobs(Mat input, double minArea, double[] circularity,
		Boolean darkBlobs, MatOfKeyPoint blobList) {
		FeatureDetector blobDet = FeatureDetector.create(FeatureDetector.SIMPLEBLOB);
		try {
			File tempFile = File.createTempFile("config", ".xml");

			StringBuilder config = new StringBuilder();

			config.append("<?xml version=\"1.0\"?>\n");
			config.append("<opencv_storage>\n");
			config.append("<thresholdStep>10.</thresholdStep>\n");
			config.append("<minThreshold>50.</minThreshold>\n");
			config.append("<maxThreshold>220.</maxThreshold>\n");
			config.append("<minRepeatability>2</minRepeatability>\n");
			config.append("<minDistBetweenBlobs>10.</minDistBetweenBlobs>\n");
			config.append("<filterByColor>1</filterByColor>\n");
			config.append("<blobColor>");
			config.append((darkBlobs ? 0 : 255));
			config.append("</blobColor>\n");
			config.append("<filterByArea>1</filterByArea>\n");
			config.append("<minArea>");
			config.append(minArea);
			config.append("</minArea>\n");
			config.append("<maxArea>");
			config.append(Integer.MAX_VALUE);
			config.append("</maxArea>\n");
			config.append("<filterByCircularity>1</filterByCircularity>\n");
			config.append("<minCircularity>");
			config.append(circularity[0]);
			config.append("</minCircularity>\n");
			config.append("<maxCircularity>");
			config.append(circularity[1]);
			config.append("</maxCircularity>\n");
			config.append("<filterByInertia>1</filterByInertia>\n");
			config.append("<minInertiaRatio>0.1</minInertiaRatio>\n");
			config.append("<maxInertiaRatio>" + Integer.MAX_VALUE + "</maxInertiaRatio>\n");
			config.append("<filterByConvexity>1</filterByConvexity>\n");
			config.append("<minConvexity>0.95</minConvexity>\n");
			config.append("<maxConvexity>" + Integer.MAX_VALUE + "</maxConvexity>\n");
			config.append("</opencv_storage>\n");
			FileWriter writer;
			writer = new FileWriter(tempFile, false);
			writer.write(config.toString());
			writer.close();
			blobDet.read(tempFile.getPath());
		} catch (IOException e) {
			e.printStackTrace();
		}

		blobDet.detect(input, blobList);
	}




}

